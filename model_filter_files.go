package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
)

type MockInfo struct {
	targetPath    string
	sourceRepo    string
	targetPackage string
	interfaces    []string
}

// FilesOps Methods are nulifying state files on error.
type FilesOps struct {
	writers []io.Writer // assess if more than one needed
	e       error       // only one error for simplicity

	filePaths []string
	content   []string // contains extracted rows

	spool    []string
	spooling bool

	rootFolder string // used in Makefile generation
}

const mockgenBinaryPath = "mockgen"
const mockgenPackageName = "mock"
const makefileName = "Makefile1"

// SelectBy Method would append to state content rows containing passed pattern.
// Only files containing pattern would remain in state.
func (f *FilesOps) ContentExtractByPattern(pattern string) *FilesOps {
	if f.e != nil {
		return nil
	}

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for selection"),
		}
	}

	var paths []string

	for _, path := range f.filePaths {
		fileHandler, errOpen := os.Open(path)
		if errOpen != nil {
			return &FilesOps{
				e: errOpen,
			}
		}
		defer fileHandler.Close()

		scanner := bufio.NewScanner(fileHandler)

		for scanner.Scan() {
			lineContent := scanner.Text()

			if strings.Contains(lineContent, pattern) {
				f.content = append(f.content, lineContent)
				paths = append(paths, path)
			}
		}
	}

	f.filePaths = paths

	return f
}

// ContentAppendMockTargetsMakefile Method would append to Makefile target to re-create mock files.
func (f *FilesOps) ContentAppendMockTargetsMakefile(rootFolder string) *FilesOps {
	if f.e != nil {
		return nil
	}

	f.FilterByContent("// Code generated by MockGen. DO NOT EDIT.")
	f.ContentExtractByPattern("// Source:")

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for Makefile mock generation"),
		}
	}

	makefileTarget := []string{".PHONY: gen-mocks", "gen-mocks:"}

	for i := 0; i < len(f.filePaths); i++ {
		content := strings.Split(f.content[i], " ")

		e := createMockTargetEntry(f.filePaths[i], mockgenPackageName, content[2], content[4][:len(content[4])-1])
		makefileTarget = append(makefileTarget, e)
	}

	fmt.Println(makefileTarget)

	f.FilesCreate([]string{rootFolder + "/" + makefileName}...)
	f.SearchByFolder(rootFolder).FilterByFileName(makefileName).PrintFileNames(os.Stdout)
	f.ContentAppend(strings.Join(makefileTarget, "\n"))

	return f
}

func createMockTargetEntry(destinationFile, packageName, repo, interfaceName string) string {
	return strings.Join([]string{"@" + mockgenBinaryPath, "-destination=" + destinationFile, "-package=" + packageName, repo, interfaceName}, " ")
}

// Replace Method would replace old string with new string searching in state files.
func (f *FilesOps) ContentReplace(old, new string) *FilesOps {
	if f.e != nil {
		return nil
	}

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for replace"),
		}
	}

	for _, file := range f.filePaths {
		content, errRead := os.ReadFile(file)
		if errRead != nil {
			return &FilesOps{
				e: errRead,
			}
		}

		data := strings.ReplaceAll(string(content), old, new)

		errWrite := ioutil.WriteFile(file, []byte(data), 0644)
		if errWrite != nil {
			return &FilesOps{
				e: errWrite,
			}
		}
	}

	return f
}

// Append Method would append text to state files.
func (f *FilesOps) ContentAppend(text string) *FilesOps {
	if f.e != nil {
		return nil
	}

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for append"),
		}
	}

	for _, file := range f.filePaths {
		fmt.Println("reading:", file)

		existingContent, errRead := os.ReadFile(file)
		if errRead != nil {
			return &FilesOps{
				e: errRead,
			}
		}

		newContent := string(existingContent) + "\n" + text

		errWrite := ioutil.WriteFile(file, []byte(newContent), 0644)
		if errWrite != nil {
			return &FilesOps{
				e: errWrite,
			}
		}
	}

	return f
}
