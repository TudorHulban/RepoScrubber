package main

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"strings"
)

// ContentAdd Method would append to state content.
func (f *FilesOps) ContentAdd(c string) *FilesOps {
	if f.e != nil {
		return nil
	}

	f.content = append(f.content, c)

	return f
}

// ContentExtractByPattern Method would append to state content rows containing passed pattern.
// Only files containing pattern would remain in state.
func (f *FilesOps) ContentAddByPattern(pattern string) *FilesOps {
	if f.e != nil {
		return nil
	}

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for selection"),
		}
	}

	var paths []string

	for _, path := range f.filePaths {
		fileHandler, errOpen := os.Open(path)
		if errOpen != nil {
			return &FilesOps{
				e: errOpen,
			}
		}
		defer fileHandler.Close()

		scanner := bufio.NewScanner(fileHandler)

		for scanner.Scan() {
			lineContent := scanner.Text()

			if strings.Contains(lineContent, pattern) {
				f.content = append(f.content, lineContent)
				paths = append(paths, path)
			}
		}
	}

	f.filePaths = paths

	return f
}

// ContentAppendMockTargetsMakefile Method would append to Makefile target to re-create mock files.
func (f *FilesOps) ContentAppendMockTargetsMakefile(rootFolder string) *FilesOps {
	if f.e != nil {
		return nil
	}

	f.FilterByContent("// Code generated by MockGen. DO NOT EDIT.")
	f.ContentAddByPattern("// Source:")

	if len(f.filePaths) == 0 {
		return &FilesOps{
			e: errors.New("no files to consider for Makefile mock generation"),
		}
	}

	makefileTarget := []string{".PHONY: gen-mocks", "gen-mocks:"}

	for i := 0; i < len(f.filePaths); i++ {
		content := strings.Split(f.content[i], " ")

		e := createMockTargetEntry(f.filePaths[i], mockgenPackageName, content[2], content[4][:len(content[4])-1])
		makefileTarget = append(makefileTarget, e)
	}

	fmt.Println(makefileTarget)

	f.FilesCreate([]string{rootFolder + "/" + makefileName}...)
	f.SearchByFolder(rootFolder).FilterByFileName(makefileName).PrintFileNames(os.Stdout)
	f.FilesAppend(strings.Join(makefileTarget, "\n"))

	return f
}

func createMockTargetEntry(destinationFile, packageName, repo, interfaceName string) string {
	return strings.Join([]string{"@" + mockgenBinaryPath, "-destination=" + destinationFile, "-package=" + packageName, repo, interfaceName}, " ")
}
